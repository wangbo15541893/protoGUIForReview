// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace liqu {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class App;
class AppList;
class Contact;
class ContactList;
class Sms;
class SmsList;

// ===================================================================

class App : public ::google::protobuf::Message {
 public:
  App();
  virtual ~App();

  App(const App& from);

  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const App& default_instance();

  void Swap(App* other);

  // implements Message ----------------------------------------------

  App* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const App& from);
  void MergeFrom(const App& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pakcage = 1;
  inline bool has_pakcage() const;
  inline void clear_pakcage();
  static const int kPakcageFieldNumber = 1;
  inline const ::std::string& pakcage() const;
  inline void set_pakcage(const ::std::string& value);
  inline void set_pakcage(const char* value);
  inline void set_pakcage(const char* value, size_t size);
  inline ::std::string* mutable_pakcage();
  inline ::std::string* release_pakcage();
  inline void set_allocated_pakcage(::std::string* pakcage);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string installdir = 4;
  inline bool has_installdir() const;
  inline void clear_installdir();
  static const int kInstalldirFieldNumber = 4;
  inline const ::std::string& installdir() const;
  inline void set_installdir(const ::std::string& value);
  inline void set_installdir(const char* value);
  inline void set_installdir(const char* value, size_t size);
  inline ::std::string* mutable_installdir();
  inline ::std::string* release_installdir();
  inline void set_allocated_installdir(::std::string* installdir);

  // optional string permission = 5;
  inline bool has_permission() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 5;
  inline const ::std::string& permission() const;
  inline void set_permission(const ::std::string& value);
  inline void set_permission(const char* value);
  inline void set_permission(const char* value, size_t size);
  inline ::std::string* mutable_permission();
  inline ::std::string* release_permission();
  inline void set_allocated_permission(::std::string* permission);

  // optional string signature = 6;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 6;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:com.liqu.protobuf.App)
 private:
  inline void set_has_pakcage();
  inline void clear_has_pakcage();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_installdir();
  inline void clear_has_installdir();
  inline void set_has_permission();
  inline void clear_has_permission();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pakcage_;
  ::std::string* name_;
  ::std::string* version_;
  ::std::string* installdir_;
  ::std::string* permission_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static App* default_instance_;
};
// -------------------------------------------------------------------
//act --andy
class AppList : public ::google::protobuf::Message {
 public:
  AppList();
  virtual ~AppList();

  AppList(const AppList& from);

  inline AppList& operator=(const AppList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppList& default_instance();

  void Swap(AppList* other);

  // implements Message ----------------------------------------------

  AppList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppList& from);
  void MergeFrom(const AppList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.liqu.protobuf.App apps = 1;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 1;
  inline const ::com::liqu::protobuf::App& apps(int index) const;
  inline ::com::liqu::protobuf::App* mutable_apps(int index);
  inline ::com::liqu::protobuf::App* add_apps();
  inline const ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::App >&
      apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::App >*
      mutable_apps();

  // @@protoc_insertion_point(class_scope:com.liqu.protobuf.AppList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::App > apps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static AppList* default_instance_;
};
// -------------------------------------------------------------------

class Contact : public ::google::protobuf::Message {
 public:
  Contact();
  virtual ~Contact();

  Contact(const Contact& from);

  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Contact& default_instance();

  void Swap(Contact* other);

  // implements Message ----------------------------------------------

  Contact* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Contact& from);
  void MergeFrom(const Contact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string phonenumber = 3;
  inline bool has_phonenumber() const;
  inline void clear_phonenumber();
  static const int kPhonenumberFieldNumber = 3;
  inline const ::std::string& phonenumber() const;
  inline void set_phonenumber(const ::std::string& value);
  inline void set_phonenumber(const char* value);
  inline void set_phonenumber(const char* value, size_t size);
  inline ::std::string* mutable_phonenumber();
  inline ::std::string* release_phonenumber();
  inline void set_allocated_phonenumber(::std::string* phonenumber);

  // @@protoc_insertion_point(class_scope:com.liqu.protobuf.Contact)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_phonenumber();
  inline void clear_has_phonenumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* phonenumber_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Contact* default_instance_;
};
// -------------------------------------------------------------------

class ContactList : public ::google::protobuf::Message {
 public:
  ContactList();
  virtual ~ContactList();

  ContactList(const ContactList& from);

  inline ContactList& operator=(const ContactList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactList& default_instance();

  void Swap(ContactList* other);

  // implements Message ----------------------------------------------

  ContactList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContactList& from);
  void MergeFrom(const ContactList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.liqu.protobuf.Contact person = 1;
  inline int person_size() const;
  inline void clear_person();
  static const int kPersonFieldNumber = 1;
  inline const ::com::liqu::protobuf::Contact& person(int index) const;
  inline ::com::liqu::protobuf::Contact* mutable_person(int index);
  inline ::com::liqu::protobuf::Contact* add_person();
  inline const ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::Contact >&
      person() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::Contact >*
      mutable_person();

  // @@protoc_insertion_point(class_scope:com.liqu.protobuf.ContactList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::Contact > person_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ContactList* default_instance_;
};
// -------------------------------------------------------------------

class Sms : public ::google::protobuf::Message {
 public:
  Sms();
  virtual ~Sms();

  Sms(const Sms& from);

  inline Sms& operator=(const Sms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sms& default_instance();

  void Swap(Sms* other);

  // implements Message ----------------------------------------------

  Sms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sms& from);
  void MergeFrom(const Sms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string from = 2;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 2;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // optional string to = 3;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 3;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // optional string group = 4;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 4;
  inline const ::std::string& group() const;
  inline void set_group(const ::std::string& value);
  inline void set_group(const char* value);
  inline void set_group(const char* value, size_t size);
  inline ::std::string* mutable_group();
  inline ::std::string* release_group();
  inline void set_allocated_group(::std::string* group);

  // optional string message = 5;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 5;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional int64 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.liqu.protobuf.Sms)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_;
  ::std::string* to_;
  ::std::string* group_;
  ::std::string* message_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Sms* default_instance_;
};
// -------------------------------------------------------------------

class SmsList : public ::google::protobuf::Message {
 public:
  SmsList();
  virtual ~SmsList();

  SmsList(const SmsList& from);

  inline SmsList& operator=(const SmsList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmsList& default_instance();

  void Swap(SmsList* other);

  // implements Message ----------------------------------------------

  SmsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmsList& from);
  void MergeFrom(const SmsList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.liqu.protobuf.Sms messages = 1;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 1;
  inline const ::com::liqu::protobuf::Sms& messages(int index) const;
  inline ::com::liqu::protobuf::Sms* mutable_messages(int index);
  inline ::com::liqu::protobuf::Sms* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::Sms >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::Sms >*
      mutable_messages();

  // @@protoc_insertion_point(class_scope:com.liqu.protobuf.SmsList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::Sms > messages_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static SmsList* default_instance_;
};
// ===================================================================


// ===================================================================

// App

// optional string pakcage = 1;
inline bool App::has_pakcage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void App::set_has_pakcage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void App::clear_has_pakcage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void App::clear_pakcage() {
  if (pakcage_ != &::google::protobuf::internal::kEmptyString) {
    pakcage_->clear();
  }
  clear_has_pakcage();
}
inline const ::std::string& App::pakcage() const {
  return *pakcage_;
}
inline void App::set_pakcage(const ::std::string& value) {
  set_has_pakcage();
  if (pakcage_ == &::google::protobuf::internal::kEmptyString) {
    pakcage_ = new ::std::string;
  }
  pakcage_->assign(value);
}
inline void App::set_pakcage(const char* value) {
  set_has_pakcage();
  if (pakcage_ == &::google::protobuf::internal::kEmptyString) {
    pakcage_ = new ::std::string;
  }
  pakcage_->assign(value);
}
inline void App::set_pakcage(const char* value, size_t size) {
  set_has_pakcage();
  if (pakcage_ == &::google::protobuf::internal::kEmptyString) {
    pakcage_ = new ::std::string;
  }
  pakcage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_pakcage() {
  set_has_pakcage();
  if (pakcage_ == &::google::protobuf::internal::kEmptyString) {
    pakcage_ = new ::std::string;
  }
  return pakcage_;
}
inline ::std::string* App::release_pakcage() {
  clear_has_pakcage();
  if (pakcage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pakcage_;
    pakcage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void App::set_allocated_pakcage(::std::string* pakcage) {
  if (pakcage_ != &::google::protobuf::internal::kEmptyString) {
    delete pakcage_;
  }
  if (pakcage) {
    set_has_pakcage();
    pakcage_ = pakcage;
  } else {
    clear_has_pakcage();
    pakcage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool App::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void App::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void App::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void App::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& App::name() const {
  return *name_;
}
inline void App::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void App::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void App::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* App::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void App::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 3;
inline bool App::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void App::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void App::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void App::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& App::version() const {
  return *version_;
}
inline void App::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void App::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void App::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* App::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void App::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string installdir = 4;
inline bool App::has_installdir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void App::set_has_installdir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void App::clear_has_installdir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void App::clear_installdir() {
  if (installdir_ != &::google::protobuf::internal::kEmptyString) {
    installdir_->clear();
  }
  clear_has_installdir();
}
inline const ::std::string& App::installdir() const {
  return *installdir_;
}
inline void App::set_installdir(const ::std::string& value) {
  set_has_installdir();
  if (installdir_ == &::google::protobuf::internal::kEmptyString) {
    installdir_ = new ::std::string;
  }
  installdir_->assign(value);
}
inline void App::set_installdir(const char* value) {
  set_has_installdir();
  if (installdir_ == &::google::protobuf::internal::kEmptyString) {
    installdir_ = new ::std::string;
  }
  installdir_->assign(value);
}
inline void App::set_installdir(const char* value, size_t size) {
  set_has_installdir();
  if (installdir_ == &::google::protobuf::internal::kEmptyString) {
    installdir_ = new ::std::string;
  }
  installdir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_installdir() {
  set_has_installdir();
  if (installdir_ == &::google::protobuf::internal::kEmptyString) {
    installdir_ = new ::std::string;
  }
  return installdir_;
}
inline ::std::string* App::release_installdir() {
  clear_has_installdir();
  if (installdir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = installdir_;
    installdir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void App::set_allocated_installdir(::std::string* installdir) {
  if (installdir_ != &::google::protobuf::internal::kEmptyString) {
    delete installdir_;
  }
  if (installdir) {
    set_has_installdir();
    installdir_ = installdir;
  } else {
    clear_has_installdir();
    installdir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string permission = 5;
inline bool App::has_permission() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void App::set_has_permission() {
  _has_bits_[0] |= 0x00000010u;
}
inline void App::clear_has_permission() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void App::clear_permission() {
  if (permission_ != &::google::protobuf::internal::kEmptyString) {
    permission_->clear();
  }
  clear_has_permission();
}
inline const ::std::string& App::permission() const {
  return *permission_;
}
inline void App::set_permission(const ::std::string& value) {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  permission_->assign(value);
}
inline void App::set_permission(const char* value) {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  permission_->assign(value);
}
inline void App::set_permission(const char* value, size_t size) {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  permission_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_permission() {
  set_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    permission_ = new ::std::string;
  }
  return permission_;
}
inline ::std::string* App::release_permission() {
  clear_has_permission();
  if (permission_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = permission_;
    permission_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void App::set_allocated_permission(::std::string* permission) {
  if (permission_ != &::google::protobuf::internal::kEmptyString) {
    delete permission_;
  }
  if (permission) {
    set_has_permission();
    permission_ = permission;
  } else {
    clear_has_permission();
    permission_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string signature = 6;
inline bool App::has_signature() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void App::set_has_signature() {
  _has_bits_[0] |= 0x00000020u;
}
inline void App::clear_has_signature() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void App::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& App::signature() const {
  return *signature_;
}
inline void App::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void App::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void App::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* App::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void App::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AppList

// repeated .com.liqu.protobuf.App apps = 1;
inline int AppList::apps_size() const {
  return apps_.size();
}
inline void AppList::clear_apps() {
  apps_.Clear();
}
inline const ::com::liqu::protobuf::App& AppList::apps(int index) const {
  return apps_.Get(index);
}
inline ::com::liqu::protobuf::App* AppList::mutable_apps(int index) {
  return apps_.Mutable(index);
}
inline ::com::liqu::protobuf::App* AppList::add_apps() {
  return apps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::App >&
AppList::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::App >*
AppList::mutable_apps() {
  return &apps_;
}

// -------------------------------------------------------------------

// Contact

// optional int32 id = 1;
inline bool Contact::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Contact::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Contact::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Contact::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Contact::id() const {
  return id_;
}
inline void Contact::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Contact::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Contact::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Contact::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Contact::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Contact::name() const {
  return *name_;
}
inline void Contact::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Contact::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Contact::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Contact::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Contact::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phonenumber = 3;
inline bool Contact::has_phonenumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Contact::set_has_phonenumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Contact::clear_has_phonenumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Contact::clear_phonenumber() {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    phonenumber_->clear();
  }
  clear_has_phonenumber();
}
inline const ::std::string& Contact::phonenumber() const {
  return *phonenumber_;
}
inline void Contact::set_phonenumber(const ::std::string& value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void Contact::set_phonenumber(const char* value) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(value);
}
inline void Contact::set_phonenumber(const char* value, size_t size) {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  phonenumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact::mutable_phonenumber() {
  set_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    phonenumber_ = new ::std::string;
  }
  return phonenumber_;
}
inline ::std::string* Contact::release_phonenumber() {
  clear_has_phonenumber();
  if (phonenumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phonenumber_;
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Contact::set_allocated_phonenumber(::std::string* phonenumber) {
  if (phonenumber_ != &::google::protobuf::internal::kEmptyString) {
    delete phonenumber_;
  }
  if (phonenumber) {
    set_has_phonenumber();
    phonenumber_ = phonenumber;
  } else {
    clear_has_phonenumber();
    phonenumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContactList

// repeated .com.liqu.protobuf.Contact person = 1;
inline int ContactList::person_size() const {
  return person_.size();
}
inline void ContactList::clear_person() {
  person_.Clear();
}
inline const ::com::liqu::protobuf::Contact& ContactList::person(int index) const {
  return person_.Get(index);
}
inline ::com::liqu::protobuf::Contact* ContactList::mutable_person(int index) {
  return person_.Mutable(index);
}
inline ::com::liqu::protobuf::Contact* ContactList::add_person() {
  return person_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::Contact >&
ContactList::person() const {
  return person_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::Contact >*
ContactList::mutable_person() {
  return &person_;
}

// -------------------------------------------------------------------

// Sms

// optional int32 id = 1;
inline bool Sms::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sms::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sms::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sms::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Sms::id() const {
  return id_;
}
inline void Sms::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string from = 2;
inline bool Sms::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sms::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sms::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sms::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& Sms::from() const {
  return *from_;
}
inline void Sms::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Sms::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Sms::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Sms::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* Sms::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Sms::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to = 3;
inline bool Sms::has_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sms::set_has_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sms::clear_has_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sms::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& Sms::to() const {
  return *to_;
}
inline void Sms::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void Sms::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void Sms::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Sms::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* Sms::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Sms::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string group = 4;
inline bool Sms::has_group() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sms::set_has_group() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Sms::clear_has_group() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Sms::clear_group() {
  if (group_ != &::google::protobuf::internal::kEmptyString) {
    group_->clear();
  }
  clear_has_group();
}
inline const ::std::string& Sms::group() const {
  return *group_;
}
inline void Sms::set_group(const ::std::string& value) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void Sms::set_group(const char* value) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void Sms::set_group(const char* value, size_t size) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Sms::mutable_group() {
  set_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    group_ = new ::std::string;
  }
  return group_;
}
inline ::std::string* Sms::release_group() {
  clear_has_group();
  if (group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_;
    group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Sms::set_allocated_group(::std::string* group) {
  if (group_ != &::google::protobuf::internal::kEmptyString) {
    delete group_;
  }
  if (group) {
    set_has_group();
    group_ = group;
  } else {
    clear_has_group();
    group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string message = 5;
inline bool Sms::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Sms::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Sms::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Sms::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Sms::message() const {
  return *message_;
}
inline void Sms::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Sms::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Sms::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Sms::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Sms::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Sms::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 time = 6;
inline bool Sms::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Sms::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Sms::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Sms::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Sms::time() const {
  return time_;
}
inline void Sms::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// SmsList

// repeated .com.liqu.protobuf.Sms messages = 1;
inline int SmsList::messages_size() const {
  return messages_.size();
}
inline void SmsList::clear_messages() {
  messages_.Clear();
}
inline const ::com::liqu::protobuf::Sms& SmsList::messages(int index) const {
  return messages_.Get(index);
}
inline ::com::liqu::protobuf::Sms* SmsList::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline ::com::liqu::protobuf::Sms* SmsList::add_messages() {
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::Sms >&
SmsList::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::liqu::protobuf::Sms >*
SmsList::mutable_messages() {
  return &messages_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace liqu
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
